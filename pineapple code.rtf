{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang16393{\fonttbl{\f0\fnil Courier New;}{\f1\fnil\fcharset0 Courier New;}{\f2\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue128;\red0\green0\blue0;\red102\green14\blue122;\red0\green0\blue255;\red128\green128\blue128;\red128\green128\blue0;\red0\green128\blue0;\red255\green255\blue255;}
{\*\generator Riched20 6.3.9600}\viewkind4\uc1 
\pard\box\brdrdash\brdrw0 \cbpat8\sa200\sl276\slmult1\cf1\b\f0\fs18\lang9 package \cf2\b0 com.pineapple.game;\line\line\cf1\b import \cf2\b0 com.badlogic.gdx.Game;\line\cf1\b import \cf2\b0 com.badlogic.gdx.graphics.g2d.BitmapFont;\line\cf1\b import \cf2\b0 com.badlogic.gdx.graphics.g2d.SpriteBatch;\line\cf1\b import \cf2\b0 com.pineapple.game.Screens.MainMenuScreen;\line\cf1\b import \cf2\b0 com.pineapple.game.Screens.PlayScreen;\line\line\cf1\b public class \cf2\b0 GamePanel \cf1\b extends \cf2\b0 Game \{\line\tab\cf1\b public static final int \cf3\i N_WIDTH \cf2\b0\i0 = \cf4 400\cf2 ;\line\tab\cf1\b public static final int \cf3\i N_HEIGHT \cf2\b0\i0 = \cf4 208\cf2 ;\line\tab\cf1\b public static final float \cf3\i PPM \cf2\b0\i0 = \cf4 100\cf2 ;\line\line\tab\cf5\i //BOX2 COLLISION BITS\line\tab\cf1\b\i0 public static final short \cf3\i NOTHING_BIT \cf2\b0\i0 = \cf4 0\cf2 ;\line\tab\cf1\b public static final short \cf3\i GROUND_BIT \cf2\b0\i0 = \cf4 1\cf2 ;\line\tab\cf1\b public static final short \cf3\i SHAY_BIT \cf2\b0\i0 = \cf4 2\cf2 ;\line\tab\cf1\b public static final short \cf3\i ENEMY_BIT \cf2\b0\i0 = \cf4 62\cf2 ;\line\tab\cf1\b public static final short \cf3\i OBJECT_BIT \cf2\b0\i0 = \cf4 32\cf2 ;\line\tab\cf1\b public static final short \cf3\i HEAD_BIT \cf2\b0\i0 = \cf4 128\cf2 ;\line\line\tab\cf1\b public \cf2\b0 SpriteBatch \cf3\b batch\cf2\b0 ;\line\tab\cf1\b public \cf2\b0 BitmapFont \cf3\b font\cf2\b0 ;\line\line\tab\cf6 @Override\line\tab\cf1\b public void \cf2\b0 create() \{\line\tab\tab\cf3\b batch \cf2\b0 = \cf1\b new \cf2\b0 SpriteBatch();\line\tab\tab\cf5\i //setScreen(new PlayScreen(this));\line\tab\tab\cf3\b\i0 font \cf2\b0 = \cf1\b new \cf2\b0 BitmapFont();\line\tab\tab\cf1\b this\cf2\b0 .setScreen(\cf1\b new \cf2\b0 MainMenuScreen(\cf1\b this\cf2\b0 ));\line\tab\}\line\line\tab\cf6 @Override\line\tab\cf1\b public void \cf2\b0 render() \{\line\tab\tab\cf1\b super\cf2\b0 .render();\line\tab\}\line\line\tab\cf1\b public void \cf2\b0 dispose() \{\line\tab\tab\cf3\b batch\cf2\b0 .dispose();\line\tab\tab\cf3\b font\cf2\b0 .dispose();\line\tab\}\line\}\par
\f1\lang16393 //MainScreen\par
\cf1\b\f0 package \cf2\b0 com.pineapple.game.Screens;\line\line\line\cf1\b import \cf2\b0 com.badlogic.gdx.Gdx;\line\cf1\b import \cf2\b0 com.badlogic.gdx.Screen;\line\cf1\b import \cf2\b0 com.badlogic.gdx.graphics.GL20;\line\cf1\b import \cf2\b0 com.badlogic.gdx.graphics.OrthographicCamera;\line\cf1\b import \cf2\b0 com.pineapple.game.GamePanel;\line\line\cf5\i /**\line  * Created by mohammed on 28-10-2015.\line  */\line\line\cf1\b\i0 public class \cf2\b0 MainMenuScreen \cf1\b implements \cf2\b0 Screen\{\line\line         \cf1\b final \cf2\b0 GamePanel \cf3\b game\cf2\b0 ;\line\line         OrthographicCamera \cf3\b camera\cf2\b0 ;\line\line         \cf1\b public \cf2\b0 MainMenuScreen(\cf1\b final \cf2\b0 GamePanel gam) \{\line             \cf3\b game \cf2\b0 = gam;\line\line             \cf3\b camera \cf2\b0 = \cf1\b new \cf2\b0 OrthographicCamera();\line             \cf3\b camera\cf2\b0 .setToOrtho(\cf1\b false\cf2\b0 , \cf4 800\cf2 , \cf4 480\cf2 );\line\line         \}\line\line\line         \cf6 @Override\line     \cf1\b public void \cf2\b0 show() \{\line\line     \}\line\line     \cf1\b public void \cf2\b0 render(\cf1\b float \cf2\b0 delta) \{\line         Gdx.\cf3\i gl\cf2\i0 .glClearColor(\cf4 60\cf2 ,\cf4 181\cf2 ,\cf4 00\cf2 ,\cf4 0f\cf2 );\line         Gdx.\cf3\i gl\cf2\i0 .glClear(GL20.\cf3\b\i GL_COLOR_BUFFER_BIT\cf2\b0\i0 );\line\line         \cf3\b camera\cf2\b0 .update();\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .setProjectionMatrix(\cf3\b camera\cf2\b0 .\cf3\b combined\cf2\b0 );\line\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .begin();\line         \cf3\b game\cf2\b0 .\cf3\b font\cf2\b0 .draw(\cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 , \cf7\b "PINEAPPLE "\cf2\b0 , \cf4 100\cf2 , \cf4 150\cf2 );\line         \cf3\b game\cf2\b0 .\cf3\b font\cf2\b0 .draw(\cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 , \cf7\b "Tap anywhere to begin"\cf2\b0 , \cf4 100\cf2 , \cf4 100\cf2 );\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .end();\line\line         \cf1\b if \cf2\b0 (Gdx.\cf3\i input\cf2\i0 .isTouched()) \{\line             \cf3\b game\cf2\b0 .setScreen(\cf1\b new \cf2\b0 PlayScreen(\cf3\b game\cf2\b0 ));\line             dispose();\line         \}\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 resize(\cf1\b int \cf2\b0 width, \cf1\b int \cf2\b0 height) \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 pause() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 resume() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 hide() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 dispose() \{\line\line     \}\line\line\line\}\line\par
\f1 //Playscreen class\par
\cf1\b\f0 public class \cf2\b0 PlayScreen \cf1\b extends \cf2\b0 ApplicationAdapter \cf1\b implements \cf2\b0 Screen \{\line\line     \cf1\b private \cf2\b0 GamePanel \cf3\b game\cf2\b0 ;\line     \cf5\i //sprite animation\line     \cf1\b\i0 private \cf2\b0 TextureAtlas \cf3\b atlas\cf2\b0 ;\line     \cf1\b private \cf2\b0 OrthographicCamera \cf3\b gamecam\cf2\b0 ;\line     \cf1\b private \cf2\b0 Viewport \cf3\b port\cf2\b0 ;\line     \cf1\b private \cf2\b0 HUD \cf3\b hud\cf2\b0 ;\line     \cf5\i //Tiledmap variables\line     \cf1\b\i0 private \cf2\b0 TmxMapLoader \cf3\b mapLoader\cf2\b0 ;\line     \cf1\b private \cf2\b0 TiledMap \cf3\b map\cf2\b0 ;\line     \cf1\b private \cf2\b0 OrthogonalTiledMapRenderer \cf3\b renderer\cf2\b0 ;\line     \cf5\i //box2d variables\line     \cf1\b\i0 private \cf2\b0 World \cf3\b world\cf2\b0 ;\line     \cf1\b private \cf2\b0 Box2DDebugRenderer \cf3\b b2dr\cf2\b0 ;\line     \cf1\b private \cf2\b0 B2WorldCreator \cf3\b creator\cf2\b0 ;\line     \cf5\i //Sprite characters\line     \cf1\b\i0 private \cf2\b0 Shay \cf3\b player\cf2\b0 ;\line\line\line                \cf1\b public  \cf2\b0 PlayScreen (GamePanel game) \{\line         \cf5\i //texturepacker sprite\line         \cf3\b\i0 atlas\cf2\b0 =\cf1\b new \cf2\b0 TextureAtlas(\cf7\b "p.pack"\cf2\b0 );\line         \cf1\b this\cf2\b0 .\cf3\b game \cf2\b0 = game;\line         \cf3\b gamecam \cf2\b0 = \cf1\b new \cf2\b0 OrthographicCamera();\line         \cf3\b port \cf2\b0 = \cf1\b new \cf2\b0 FitViewport(GamePanel.\cf3\b\i N_WIDTH \cf2\b0\i0 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , GamePanel.\cf3\b\i N_HEIGHT \cf2\b0\i0 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , \cf3\b gamecam\cf2\b0 );\line         \cf3\b hud \cf2\b0 = \cf1\b new \cf2\b0 HUD(game.\cf3\b batch\cf2\b0 );\line         \cf3\b mapLoader \cf2\b0 = \cf1\b new \cf2\b0 TmxMapLoader();\line         \cf3\b map \cf2\b0 = \cf3\b mapLoader\cf2\b0 .load(\cf7\b "level1.tmx"\cf2\b0 );\line         \cf3\b renderer \cf2\b0 = \cf1\b new \cf2\b0 OrthogonalTiledMapRenderer(\cf3\b map\cf2\b0 , \cf4 1 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         \cf3\b gamecam\cf2\b0 .\cf3\b position\cf2\b0 .set(\cf3\b port\cf2\b0 .getWorldWidth() / \cf4 2\cf2 , \cf3\b port\cf2\b0 .getWorldHeight() / \cf4 2\cf2 , \cf4 0\cf2 );\line         \cf3\b world \cf2\b0 = \cf1\b new \cf2\b0 World(\cf1\b new \cf2\b0 Vector2(\cf4 0\cf2 , -\cf4 10\cf2 ), \cf1\b true\cf2\b0 );\line         \cf3\b b2dr \cf2\b0 = \cf1\b new \cf2\b0 Box2DDebugRenderer();\line         \cf3\b creator\cf2\b0 =\cf1\b new \cf2\b0 B2WorldCreator(\cf1\b this\cf2\b0 );\line         \cf3\b player \cf2\b0 =  \cf1\b new \cf2\b0 Shay(\cf1\b this\cf2\b0 );\line         \cf3\b world\cf2\b0 .setContactListener(\cf1\b new \cf2\b0 WorldContactListener());\line\line     \}\line\line     \cf1\b public \cf2\b0 TextureAtlas getAtlas()\{\line\line         \cf1\b return \cf3 atlas\cf2\b0 ;\line     \}\line    \cf6 @Override\line     \cf1\b public void \cf2\b0 show() \{\line\line     \}\line     \cf1\b public void \cf2\b0 handleInput(\cf1\b float \cf2\b0 dt) \{\line         \cf5\i //handling user input keystrokes\line         \cf1\b\i0 if \cf2\b0 (\cf3\b player\cf2\b0 .\cf3\b currentState \cf2\b0 != Shay.State.\cf3\b\i DEAD\cf2\b0\i0 ) \{\line             \cf1\b if \cf2\b0 (Gdx.\cf3\i input\cf2\i0 .isKeyJustPressed(Input.Keys.\cf3\b\i UP\cf2\b0\i0 ))\line                 \cf5\i //player.b2body.applyLinearImpulse(new Vector2(0.3f, 0), player.b2body.getWorldCenter(), true);\line                 \cf3\b\i0 player\cf2\b0 .\cf3\b b2body\cf2\b0 .applyLinearImpulse(\cf1\b new \cf2\b0 Vector2(\cf4 0\cf2 , \cf4 0.4f\cf2 ), \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getWorldCenter(), \cf1\b true\cf2\b0 );\line             \cf1\b if \cf2\b0 (Gdx.\cf3\i input\cf2\i0 .isKeyJustPressed(Input.Keys.\cf3\b\i RIGHT\cf2\b0\i0 ) && \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b x \cf2\b0 <= \cf4 2\cf2 )\line                 \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .applyLinearImpulse(\cf1\b new \cf2\b0 Vector2(\cf4 0.5f\cf2 , \cf4 0\cf2 ), \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getWorldCenter(), \cf1\b true\cf2\b0 );\line             \cf1\b if \cf2\b0 (Gdx.\cf3\i input\cf2\i0 .isKeyJustPressed(Input.Keys.\cf3\b\i LEFT\cf2\b0\i0 ) && \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b x \cf2\b0 >= -\cf4 2\cf2 )\line                 \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .applyLinearImpulse(\cf1\b new \cf2\b0 Vector2(-\cf4 0.5f\cf2 , \cf4 0\cf2 ), \cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getWorldCenter(), \cf1\b true\cf2\b0 );\line         \}\line     \}\line     \cf1\b public void \cf2\b0 update(\cf1\b float \cf2\b0 dt)\{\line         handleInput(dt);\line         \cf3\b world\cf2\b0 .step(\cf4 1 \cf2 / \cf4 60f\cf2 , \cf4 6\cf2 , \cf4 2\cf2 );\line         \cf3\b gamecam\cf2\b0 .\cf3\b position\cf2\b0 .\cf3\b x\cf2\b0 =\cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getPosition().\cf3\b x\cf2\b0 ;\line         \cf3\b gamecam\cf2\b0 .update();\line         \cf3\b player\cf2\b0 .update(dt);\line         \cf1\b for\cf2\b0 (Enemy enemy:\cf3\b creator\cf2\b0 .getPapples())\line         enemy.update(dt);\line         \cf5\i //attach the gamecam to the player x coordinate\line         \cf1\b\i0 if\cf2\b0 (\cf3\b player\cf2\b0 .\cf3\b currentState\cf2\b0 !=Shay.State.\cf3\b\i DEAD\cf2\b0\i0 )\{\line             \cf3\b gamecam\cf2\b0 .\cf3\b position\cf2\b0 .\cf3\b x\cf2\b0 =\cf3\b player\cf2\b0 .\cf3\b b2body\cf2\b0 .getPosition().\cf3\b x\cf2\b0 ;\line         \}\line\line         \cf3\b renderer\cf2\b0 .setView(\cf3\b gamecam\cf2\b0 );\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 render(\cf1\b float \cf2\b0 delta) \{\line         \cf5\i //seperate update logic from render()\line         \cf2\i0 update(delta);\line         Gdx.\cf3\i gl\cf2\i0 .glClearColor(\cf4 0\cf2 , \cf4 0\cf2 , \cf4 0\cf2 , \cf4 1\cf2 );\line         Gdx.\cf3\i gl\cf2\i0 .glClear(GL20.\cf3\b\i GL_COLOR_BUFFER_BIT\cf2\b0\i0 );\line\line         \cf5\i //render game map\line         \cf3\b\i0 renderer\cf2\b0 .render();\line         \cf5\i //rendering box2d debug lines\line         \cf3\b\i0 b2dr\cf2\b0 .render(\cf3\b world\cf2\b0 , \cf3\b gamecam\cf2\b0 .\cf3\b combined\cf2\b0 );\line\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .setProjectionMatrix(\cf3\b gamecam\cf2\b0 .\cf3\b combined\cf2\b0 );\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .begin();\line         \cf3\b player\cf2\b0 .draw(\cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 );\line         \cf1\b for\cf2\b0 (Enemy enemy:\cf3\b creator\cf2\b0 .getPapples())\line             enemy.draw(\cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 );\line         \cf3\b game\cf2\b0 .\cf3\b batch\cf2\b0 .end();\line         \cf5\i //batch now draws wat HUD sees\line         \cf3\b\i0 game\cf2\b0 .\cf3\b batch\cf2\b0 .setProjectionMatrix(\cf3\b hud\cf2\b0 .\cf3\b stage\cf2\b0 .getCamera().\cf3\b combined\cf2\b0 );\line         \cf3\b hud\cf2\b0 .\cf3\b stage\cf2\b0 .draw();\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 resize(\cf1\b int \cf2\b0 width, \cf1\b int \cf2\b0 height) \{\line\line         \cf3\b port\cf2\b0 .update(width, height);\line     \}\line\line     \cf1\b public \cf2\b0 TiledMap getMap()\{\line         \cf1\b return \cf3 map\cf2\b0 ;\line     \}\line\line     \cf1\b public \cf2\b0 World getWorld()\{\line         \cf1\b return \cf3 world\cf2\b0 ;\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 pause() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 resume() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 hide() \{\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 dispose() \{\line         \cf3\b map\cf2\b0 .dispose();\line         \cf3\b renderer\cf2\b0 .dispose();\line         \cf3\b world\cf2\b0 .dispose();\line         \cf3\b b2dr\cf2\b0 .dispose();\line         \cf3\b hud\cf2\b0 .dispose();\line\line     \}\line\}\par
\f1 //Shay player  class\par
\cf1\b\f0\lang9 public class \cf2\b0 Shay \cf1\b extends \cf2\b0 Sprite \{\line     \cf1\b public enum \cf2\b0 State \{\cf3\b\i FALLING\cf2\b0\i0 , \cf3\b\i JUMPING\cf2\b0\i0 , \cf3\b\i STANDING\cf2\b0\i0 , \cf3\b\i RUNNING\cf2\b0\i0 ,\cf3\b\i DEAD\cf2\b0\i0\}\line\line     ;\line     \cf1\b public \cf2\b0 State \cf3\b currentState\cf2\b0 ;\line     \cf1\b public \cf2\b0 State \cf3\b previousState\cf2\b0 ;\line     \cf1\b public \cf2\b0 World \cf3\b world\cf2\b0 ;\line     \cf1\b public \cf2\b0 Body \cf3\b b2body\cf2\b0 ;\line     \cf1\b private \cf2\b0 TextureRegion \cf3\b Shaystand\cf2\b0 ;\line     \cf1\b private \cf2\b0 TextureRegion \cf3\b Shaydead\cf2\b0 ;\line     \cf1\b private \cf2\b0 Animation \cf3\b Shayrun\cf2\b0 ;\line     \cf1\b private \cf2\b0 Animation \cf3\b Shayjump\cf2\b0 ;\line     \cf1\b private float \cf3 stateTimer\cf2\b0 ;\line     \cf1\b private boolean \cf3 runningRight\cf2\b0 ;\line     \cf1\b private boolean \cf3 Shayisdead\cf2\b0 ;\line\line     \cf1\b public \cf2\b0 Shay(PlayScreen screen) \{\line\line         \cf1\b super\cf2\b0 (screen.getAtlas().findRegion(\cf7\b "2015-10-27 21.57.06"\cf2\b0 ));\line         \cf1\b this\cf2\b0 .\cf3\b world \cf2\b0 = screen.getWorld();\line         \cf3\b currentState \cf2\b0 = State.\cf3\b\i STANDING\cf2\b0\i0 ;\line         \cf3\b previousState \cf2\b0 = State.\cf3\b\i STANDING\cf2\b0\i0 ;\line         \cf3\b stateTimer \cf2\b0 = \cf4 0\cf2 ;\line         \cf3\b runningRight \cf2\b0 = \cf1\b true\cf2\b0 ;\line         Array<TextureRegion> frames = \cf1\b new \cf2\b0 Array<TextureRegion>();\line         \cf1\b for \cf2\b0 (\cf1\b int \cf2\b0 i = \cf4 0\cf2 ; i < \cf4 1\cf2 ; i++)\line             frames.add(\cf1\b new \cf2\b0 TextureRegion(getTexture(), i *\cf4 16\cf2 , \cf4 0\cf2 , \cf4 40\cf2 , \cf4 40\cf2 ));\line         \cf3\b Shaystand \cf2\b0 = \cf1\b new \cf2\b0 TextureRegion(getTexture(), \cf4 1\cf2 , \cf4 1\cf2 , \cf4 40\cf2 , \cf4 40\cf2 );\line         \cf3\b Shayrun \cf2\b0 = \cf1\b new \cf2\b0 Animation(\cf4 0.1f\cf2 , frames);\line         frames.clear();\line         \cf1\b for \cf2\b0 (\cf1\b int \cf2\b0 i = \cf4 0\cf2 ; i < \cf4 1\cf2 ; i++)\line             frames.add(\cf1\b new \cf2\b0 TextureRegion(getTexture(), i *\cf4 50\cf2 , \cf4 0\cf2 , \cf4 40\cf2 , \cf4 40\cf2 ));\line         \cf3\b Shayjump \cf2\b0 = \cf1\b new \cf2\b0 Animation(\cf4 0.1f\cf2 , frames);\line         frames.clear();\line         \cf5\i //creating dead shay texture region\line         \cf3\b\i0 Shaydead\cf2\b0 =\cf1\b new \cf2\b0 TextureRegion(screen.getAtlas().findRegion(\cf7\b "2015-10-27 21.57.06"\cf2\b0 ),\cf4 45\cf2 ,\cf4 0\cf2 ,\cf4 45\cf2 ,\cf4 45\cf2 );\line\line         defineShay();\line         setBounds(\cf4 1\cf2 , \cf4 1\cf2 , \cf4 32\cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , \cf4 32\cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         setRegion(\cf3\b Shaystand\cf2\b0 );\line\line\line     \}\line\line     \cf1\b public void \cf2\b0 update(\cf1\b float \cf2\b0 dt) \{\line         setPosition(\cf3\b b2body\cf2\b0 .getPosition().\cf3\b x \cf2\b0 - getWidth() / \cf4 2\cf2 , \cf3\b b2body\cf2\b0 .getPosition().\cf3\b y \cf2\b0 - getHeight() / \cf4 2\cf2 );\line         setRegion(getFrame(dt));\line     \}\line\line     \cf1\b public \cf2\b0 TextureRegion getFrame(\cf1\b float \cf2\b0 dt) \{\line         \cf3\b currentState \cf2\b0 = getState();\line         TextureRegion region;\line         \cf1\b switch \cf2\b0 (\cf3\b currentState\cf2\b0 ) \{\line             \cf1\b case \cf3\i DEAD\cf2\b0\i0 :\line                 region=\cf3\b Shaydead\cf2\b0 ;\line             \cf1\b case \cf3\i JUMPING\cf2\b0\i0 :\line                 region = \cf3\b Shayjump\cf2\b0 .getKeyFrame(\cf3\b stateTimer\cf2\b0 );\line                 \cf1\b break\cf2\b0 ;\line             \cf1\b case \cf3\i RUNNING\cf2\b0\i0 :\line                 region = \cf3\b Shayrun\cf2\b0 .getKeyFrame(\cf3\b stateTimer\cf2\b0 , \cf1\b true\cf2\b0 );\line                 \cf1\b break\cf2\b0 ;\line             \cf1\b case \cf3\i FALLING\cf2\b0\i0 :\line             \cf1\b case \cf3\i STANDING\cf2\b0\i0 :\line             \cf1\b default\cf2\b0 :\line                 region = \cf3\b Shaystand\cf2\b0 ;\line                 \cf1\b break\cf2\b0 ;\line         \}\line         \cf1\b if \cf2\b0 ((\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b x \cf2\b0 < \cf4 0 \cf2 || !\cf3\b runningRight\cf2\b0 ) && region.isFlipX()) \{\line             region.flip(\cf1\b true\cf2\b0 , \cf1\b false\cf2\b0 );\line             \cf3\b runningRight \cf2\b0 = \cf1\b false\cf2\b0 ;\line         \} \cf1\b else if \cf2\b0 ((\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b x \cf2\b0 > \cf4 0 \cf2 || \cf3\b runningRight\cf2\b0 ) && region.isFlipX()) \{\line             region.flip(\cf1\b true\cf2\b0 , \cf1\b false\cf2\b0 );\line             \cf3\b runningRight \cf2\b0 = \cf1\b true\cf2\b0 ;\line         \}\line         \cf3\b stateTimer \cf2\b0 = \cf3\b currentState \cf2\b0 == \cf3\b previousState \cf2\b0 ? \cf3\b stateTimer \cf2\b0 + dt : \cf4 0\cf2 ;\line         \cf3\b previousState \cf2\b0 = \cf3\b currentState\cf2\b0 ;\line         \cf1\b return \cf2\b0 region;\line     \}\line\line     \cf1\b public \cf2\b0 State getState() \{\line         \cf1\b if\cf2\b0 (\cf3\b Shayisdead\cf2\b0 )\line             \cf1\b return \cf2\b0 State.\cf3\b\i DEAD\cf2\b0\i0 ;\line         \cf1\b if \cf2\b0 (\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b y \cf2\b0 > \cf4 0 \cf2 || (\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b y \cf2\b0 < \cf4 0 \cf2 && \cf3\b previousState \cf2\b0 == State.\cf3\b\i JUMPING\cf2\b0\i0 ))\line             \cf1\b return \cf2\b0 State.\cf3\b\i JUMPING\cf2\b0\i0 ;\line         \cf1\b if \cf2\b0 (\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b y \cf2\b0 < \cf4 0\cf2 )\line             \cf1\b return \cf2\b0 State.\cf3\b\i FALLING\cf2\b0\i0 ;\line         \cf1\b else if \cf2\b0 (\cf3\b b2body\cf2\b0 .getLinearVelocity().\cf3\b x \cf2\b0 != \cf4 0\cf2 )\line             \cf1\b return \cf2\b0 State.\cf3\b\i RUNNING\cf2\b0\i0 ;\line         \cf1\b else return \cf2\b0 State.\cf3\b\i STANDING\cf2\b0\i0 ;\line     \}\line\line     \cf1\b public void \cf2\b0 defineShay() \{\line         BodyDef bdef = \cf1\b new \cf2\b0 BodyDef();\line         bdef.\cf3\b position\cf2\b0 .set(\cf4 32 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , \cf4 32 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         bdef.\cf3\b type \cf2\b0 = BodyDef.BodyType.\cf3\b\i DynamicBody\cf2\b0\i0 ;\line         \cf3\b b2body \cf2\b0 = \cf3\b world\cf2\b0 .createBody(bdef);\line         FixtureDef fdef = \cf1\b new \cf2\b0 FixtureDef();\line         CircleShape shape = \cf1\b new \cf2\b0 CircleShape();\line         shape.setRadius(\cf4 7 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         fdef.\cf3\b filter\cf2\b0 .\cf3\b categoryBits \cf2\b0 = GamePanel.\cf3\b\i SHAY_BIT\cf2\b0\i0 ;\line         fdef.\cf3\b filter\cf2\b0 .\cf3\b maskBits \cf2\b0 = GamePanel.\cf3\b\i GROUND_BIT \cf2\b0\i0 |\line                 GamePanel.\cf3\b\i ENEMY_BIT \cf2\b0\i0 |\line                 GamePanel.\cf3\b\i OBJECT_BIT \cf2\b0\i0 |\line                 GamePanel.\cf3\b\i HEAD_BIT\cf2\b0\i0 ;\line         fdef.\cf3\b shape \cf2\b0 = shape;\line         \cf3\b b2body\cf2\b0 .createFixture(fdef);\line         EdgeShape head = \cf1\b new \cf2\b0 EdgeShape();\line         head.set(\cf1\b new \cf2\b0 Vector2(-\cf4 2 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , \cf4 5 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 ), \cf1\b new \cf2\b0 Vector2(\cf4 2 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 , \cf4 5 \cf2 / GamePanel.\cf3\b\i PPM\cf2\b0\i0 ));\line         fdef.\cf3\b shape \cf2\b0 = head;\line         fdef.\cf3\b isSensor \cf2\b0 = \cf1\b true\cf2\b0 ;\line         \cf3\b b2body\cf2\b0 .createFixture(fdef).setUserData(\cf7\b "head"\cf2\b0 );\line\line\line     \}\line     \cf1\b public void \cf2\b0 hit()\{\line         \cf3\b Shayisdead\cf2\b0 =\cf1\b true\cf2\b0 ;\line         Filter filter=\cf1\b new \cf2\b0 Filter();\line         filter.\cf3\b maskBits\cf2\b0 =GamePanel.\cf3\b\i NOTHING_BIT\cf2\b0\i0 ;\line         \cf1\b for\cf2\b0 (Fixture fixture:\cf3\b b2body\cf2\b0 .getFixtureList())\line             fixture.setFilterData(filter);\line         \cf3\b b2body\cf2\b0 .applyLinearImpulse(\cf1\b new \cf2\b0 Vector2(\cf4 0\cf2 ,\cf4 4f\cf2 ),\cf3\b b2body\cf2\b0 .getWorldCenter(),\cf1\b true\cf2\b0 );\line     \}\line\}\par
\f1\lang16393 //Enemy fruits class\par
\cf1\b\f0 public class \cf2\b0 Papple \cf1\b extends \cf2\b0 Enemy\{\line     \cf1\b private float \cf3 stateTime\cf2\b0 ;\line     \cf1\b private \cf2\b0 com.badlogic.gdx.graphics.g2d.Animation \cf3\b walkAnimation\cf2\b0 ;\line     \cf1\b private \cf2\b0 Array<TextureRegion> \cf3\b frames\cf2\b0 ;\line     \cf1\b private boolean \cf3 setToDestroy\cf2\b0 ;\line     \cf1\b private boolean \cf3 destroyed\cf2\b0 ;\line\line     \cf1\b public \cf2\b0 Papple(PlayScreen screen, \cf1\b float \cf2\b0 x, \cf1\b float \cf2\b0 y) \{\line         \cf1\b super\cf2\b0 (screen, x, y);\line         \cf3\b frames\cf2\b0 =\cf1\b new \cf2\b0 Array<TextureRegion>();\line         \cf1\b for\cf2\b0 (\cf1\b int \cf2\b0 i=\cf4 0\cf2 ;i<\cf4 1\cf2 ;i++)\line             \cf3\b frames\cf2\b0 .add(\cf1\b new \cf2\b0 TextureRegion(screen.getAtlas().findRegion(\cf7\b "2015-10-27 21.48.14"\cf2\b0 ),i*\cf4 90\cf2 ,\cf4 0\cf2 ,\cf4 90\cf2 ,\cf4 90\cf2 ));\line         \cf3\b walkAnimation\cf2\b0 =\cf1\b new \cf2\b0 Animation(\cf4 0.4f\cf2 ,\cf3\b frames\cf2\b0 );\line         \cf3\b stateTime\cf2\b0 =\cf4 0\cf2 ;\line         setBounds(getX(),getY(),\cf4 32\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 ,\cf4 32\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         \cf3\b setToDestroy\cf2\b0 =\cf1\b false\cf2\b0 ;\line         \cf3\b destroyed\cf2\b0 =\cf1\b false\cf2\b0 ;\line\line     \}\line     \cf1\b public void \cf2\b0 update(\cf1\b float \cf2\b0 dt) \{\line         \cf3\b stateTime \cf2\b0 += dt;\line         \cf1\b if \cf2\b0 (\cf3\b setToDestroy \cf2\b0 && !\cf3\b destroyed\cf2\b0 ) \{\line             \cf3\b world\cf2\b0 .destroyBody(\cf3\b b2body\cf2\b0 );\line             \cf3\b destroyed \cf2\b0 = \cf1\b true\cf2\b0 ;\line             setRegion(\cf1\b new \cf2\b0 TextureRegion(\cf3\b screen\cf2\b0 .getAtlas().findRegion(\cf7\b "2015-10-27 21.48.14"\cf2\b0 ), \cf4 32\cf2 , \cf4 0\cf2 , \cf4 90\cf2 , \cf4 90\cf2 ));\line             \cf3\b stateTime\cf2\b0 =\cf4 0\cf2 ;\line         \}\line         \cf1\b else if \cf2\b0 (!\cf3\b destroyed\cf2\b0 ) \{\line             \cf3\b b2body\cf2\b0 .setLinearVelocity(\cf3\b velocity\cf2\b0 );\line             setPosition(\cf3\b b2body\cf2\b0 .getPosition().\cf3\b x \cf2\b0 - getWidth() / \cf4 2\cf2 , \cf3\b b2body\cf2\b0 .getPosition().\cf3\b y \cf2\b0 - getHeight() / \cf4 2\cf2 );\line             setRegion(\cf3\b walkAnimation\cf2\b0 .getKeyFrame(\cf3\b stateTime\cf2\b0 , \cf1\b true\cf2\b0 ));\line         \}\line\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 defineEnemy()\{\line         BodyDef bdef= \cf1\b new \cf2\b0 BodyDef();\line         bdef.\cf3\b position\cf2\b0 .set(getX(),getY());\cf5\i //position of the enemy body\line         \cf2\i0 bdef.\cf3\b type\cf2\b0 =BodyDef.BodyType.\cf3\b\i DynamicBody\cf2\b0\i0 ;\line         \cf3\b b2body\cf2\b0 =\cf3\b world\cf2\b0 .createBody(bdef);\line         FixtureDef fdef=\cf1\b new \cf2\b0 FixtureDef();\line         CircleShape shape=\cf1\b new \cf2\b0 CircleShape();\line         shape.setRadius(\cf4 5\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         fdef.\cf3\b filter\cf2\b0 .\cf3\b categoryBits\cf2\b0 =GamePanel.\cf3\b\i ENEMY_BIT\cf2\b0\i0 ;\line         fdef.\cf3\b filter\cf2\b0 .\cf3\b maskBits\cf2\b0 =GamePanel.\cf3\b\i GROUND_BIT \cf2\b0\i0 |\line         GamePanel.\cf3\b\i ENEMY_BIT \cf2\b0\i0 |\line         GamePanel.\cf3\b\i OBJECT_BIT\cf2\b0\i0 |\line         GamePanel.\cf3\b\i SHAY_BIT\cf2\b0\i0 ;\line         fdef.\cf3\b shape\cf2\b0 =shape;\line         \cf3\b b2body\cf2\b0 .createFixture(fdef).setUserData(\cf1\b this\cf2\b0 );\line\line         \cf5\i //create head of the fruit\line         \cf2\i0 PolygonShape head=\cf1\b new \cf2\b0 PolygonShape();\line         Vector2[] vertice=\cf1\b new \cf2\b0 Vector2[\cf4 4\cf2 ];\line         vertice[\cf4 0\cf2 ]=\cf1\b new \cf2\b0 Vector2(-\cf4 5\cf2 ,\cf4 8\cf2 ).scl(\cf4 1\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         vertice[\cf4 1\cf2 ]=\cf1\b new \cf2\b0 Vector2(\cf4 5\cf2 ,\cf4 8\cf2 ).scl(\cf4 1\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         vertice[\cf4 2\cf2 ]=\cf1\b new \cf2\b0 Vector2(-\cf4 3\cf2 ,\cf4 3\cf2 ).scl(\cf4 1\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         vertice[\cf4 3\cf2 ]=\cf1\b new \cf2\b0 Vector2(\cf4 3\cf2 ,\cf4 3\cf2 ).scl(\cf4 1\cf2 /GamePanel.\cf3\b\i PPM\cf2\b0\i0 );\line         head.set(vertice);\line         fdef.\cf3\b shape\cf2\b0 =head;\line         fdef.\cf3\b restitution\cf2\b0 =\cf4 0.5f\cf2 ;\line         fdef.\cf3\b filter\cf2\b0 .\cf3\b categoryBits\cf2\b0 =GamePanel.\cf3\b\i HEAD_BIT\cf2\b0\i0 ;\line         \cf3\b b2body\cf2\b0 .createFixture(fdef).setUserData(\cf7\b "head"\cf2\b0 );\line\line     \}\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 draw(Batch batch)\{\line         \cf1\b if\cf2\b0 (!\cf3\b destroyed\cf2\b0 ||\cf3\b stateTime\cf2\b0 <\cf4 1\cf2 )\line             \cf1\b super\cf2\b0 .draw(batch);\line     \}\line\line     \cf6 @Override\line     \cf1\b public void \cf2\b0 hitOnHead() \{\line         \cf3\b setToDestroy\cf2\b0 =\cf1\b true\cf2\b0 ;\line     \}\line\line\}\par
\lang9\par

\pard\sa200\sl276\slmult1\cf0\f2\fs22\par
}
 